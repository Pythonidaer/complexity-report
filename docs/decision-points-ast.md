# Decision Points (AST)

## decision-points/ (AST parser)

This module parses JavaScript/TypeScript source using the ESLint-compatible AST and identifies decision points (if, for, while, ternary, `&&`, `||`, `??`, `?.`, default parameters, catch, switch/case) that contribute to cyclomatic complexity. For each decision point it determines which ESLint-reported function it belongs to by matching AST function nodes to ESLint results via line number and range, so the Function Complexity Breakdown table can show per-function decision-point counts. The logic aligns with ESLint's `complexity` rule and supports both **classic** (each switch case +1) and **modified** (whole switch +1) variants via the `options.variant` parameter.

The main public API is `parseDecisionPointsAST(sourceCode, functionBoundaries, functions, filePath, projectRoot, options?)`, which returns a Promise resolving to an array of `{ type, line, functionLine, name, column?, endColumn? }` objects. When the AST node has `loc`, each decision point includes `column` and `endColumn` (0-based; `endColumn` exclusive, per ESTree) for within-line highlighting in the report (e.g. default params on a function declaration line). Optional `options.variant`: `'classic'` (default) or `'modified'`; when `'modified'`, each `SwitchStatement` emits one `'switch'` decision point; when `'classic'`, each `SwitchCase` emits a `'case'` decision point. The module parses with `@typescript-eslint/typescript-estree`, collects function nodes, matches them to ESLint function results (handling arrow functions by finding the `=>` line), builds a parent map for context (e.g. AssignmentPattern in params vs body), and classifies each candidate node (IfStatement, LogicalExpression, ConditionalExpression, etc.) into a decision-point type. `functionBoundaries` and `projectRoot` are accepted for API compatibility but are not used; boundaries and function containment are derived from the AST. Callers are `generate-complexity-report.js`, `analyze-ast-mismatches.js`, and `html-generators/file.js`.

**Dependencies:**
- @typescript-eslint/typescript-estree (parse)

**TODOs (documented for future implementation):**

- **Unused parameters:** `functionBoundaries` and `_projectRoot` are never used inside `parseDecisionPointsAST`. They exist so the signature matches what callers pass and other parsers in the pipeline expect. Consider documenting this in the function JSDoc or, if a unified API is refactored, removing them from the AST implementation.
- **parseAST defensive retry for JSX in .ts/.js:** Currently `parseAST` sets `jsx: true` only for `.tsx` and `.jsx`. For uncommon setups where JSX appears in `.ts` or `.js`, the initial parse fails. Add a retry: on parse failure for `.ts` or `.js`, retry with `jsx: true` before returning null.
- **Separate function-boundaries into AST-based (100%) vs framework-specific fallback:** The current `function-boundaries/` uses line/character scanning and framework-specific patterns (`}, [`, `}, number`). Introduce an AST-based boundary module that derives start/end from function node ranges, achieving 100% framework-agnostic accuracy. Keep the existing line-based logic only as a fallback when AST parsing fails. Remove framework-specific patterns from the core path.
- **Leverage AST for function hierarchies:** Use the same AST parsing (and AST-derived boundaries) to refine function hierarchies. Derive boundaries from AST ranges, nesting from AST parent-child structure, and callback context from AST (CallExpression callee, JSXAttribute name) so hierarchy accuracy is 100% and framework-agnostic. Fixing boundaries and extraction at the AST level will resolve hierarchy issues that cascade from boundary/extraction errors.
